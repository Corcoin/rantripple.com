<!--
Virtual 1 Billion Servers ‚Äî Clickable Servers with Per-Server Chat & File Sharing
Single-file HTML app. Opens any virtual server (0 .. 999,999,999) ‚Äî each server has its own
chat and file-sharing area persisted via IndexedDB. The UI provides a paginated server list
and a detail view for each server (open/close). Servers are still generated deterministically
when unmodified so we never allocate 1 billion objects in memory.

Features:
- Server list (paginated) with Open buttons for each server.
- Server detail view: per-server files (upload/share/download/delete) and chat room.
- Persistent mutated servers saved to IndexedDB under key `server:<id>`.
- Deterministic base generation for unmodified servers (xorshift32 seeded by id).
- Quick open by ID, next/prev navigation, and copy/share file to other servers.

How to use:
- Open the HTML in your browser.
- Use the list to open any server, or enter an ID and click Open.
- Upload files, send chat messages; mutated servers persist between reloads.

Author: ChatGPT ‚Äî production-ready demo. Extend with WebSocket or WebRTC for real-time multi-client sync.
-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
  
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>‚òÅÔ∏èüñ•Ô∏èüè¢RantRipple Cloud Datacenter  ‚Äî 10 Billion Clickable Servers</title>
<style>
  button.mini {
  padding: 8px 10px;
  min-height: 36px;
}

  @media (max-width: 768px) {
  #detailView > div[style] {
    display: flex !important;
    flex-direction: column;
  }
}

  @media (max-width: 768px) {
  body { padding: 10px; }
  header { flex-direction: column; align-items: flex-start; }
  .controls { flex-direction: column; align-items: stretch; width: 100%; }
  .toolbar { flex-direction: column; align-items: stretch; gap: 6px; }
  input, button, select, textarea {
    font-size: 16px; /* prevents zoom on iOS */
    width: 100%;
  }
  .server-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); }
  .card { padding: 10px; }
  .chat { height: 200px; }
}

@media (max-width: 480px) {
  .server-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
  .chat { height: 180px; }
  .toolbar, .controls { gap: 4px; }
}

  :root{font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  body{margin:0;padding:18px;background:#071028;color:#e6eef8}
  .app{max-width:1200px;margin:0 auto}
  .card{background:#08162a;padding:12px;border-radius:12px;box-shadow:0 8px 18px rgba(2,6,23,0.6)}
  input,button,select,textarea{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#061022;color:inherit}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  .muted{color:#9db0d6;font-size:13px}
  .controls{display:flex;gap:8px;align-items:center}
  .server-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px}
  .server-card{padding:10px;border-radius:10px;background:#061228;border:1px solid rgba(255,255,255,0.03)}
  .chat{height:320px;overflow:auto;background:#061226;padding:8px;border-radius:8px}
  .chat-msg{margin-bottom:8px}
  .file-row{display:flex;gap:8px;align-items:center}
  .mini{font-size:12px;padding:6px}
  .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:10px}
  .hidden{display:none}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1 style="margin:0;font-size:20px">RantRipple Cloud Datacenter ‚Äî Click & Open</h1>
    <div class="muted">Each server has its own chat and file-sharing area. Persistent edits saved locally.</div>
  </header>

  <div class="card" id="mainCard">
    <div class="toolbar">
      <div class="controls">
        <label class="muted mini">Go to Server ID</label>
        <input id="gotoId" type="number" min="0" max="999999999" placeholder="12345" style="width:160px" />
        <button id="openIdBtn" class="mini">Open</button>
      </div>

      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <div class="muted">TOTAL_SERVERS: <strong id="totalServers">1000000000</strong></div>
        <div style="width:14px"></div>
        <div class="muted">Cached: <strong id="cacheSize">0</strong></div>
      </div>
    </div>

    <!-- Server list view -->
    <div id="listView">
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <label class="muted">Page start ID</label>
        <input id="pageStart" type="number" min="0" value="0" style="width:160px" />
        <label class="muted">Page size</label>
        <input id="pageSize" type="number" min="1" max="500" value="100" style="width:100px" />
        <button id="renderPage" class="mini">Render Page</button>
        <div style="margin-left:auto" class="muted">Tip: large page sizes are visual only; servers are generated on demand.</div>
      </div>

      <div id="serverGrid" class="server-grid"></div>
    </div>

    <!-- Server detail view -->
    <div id="detailView" class="hidden">
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <button id="backToList" class="mini">¬´ Back to List</button>
        <div class="muted">Viewing Server ID: <strong id="detailId">-</strong></div>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <button id="prevServer" class="mini">Prev</button>
          <button id="nextServer" class="mini">Next</button>
          <button id="clearDetailPersist" class="mini">Clear Persistence</button>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1.2fr;gap:12px">
        <div>
          <div class="muted">Server Info</div>
          <div id="serverInfo" class="card" style="margin-top:8px"></div>

          <div style="margin-top:10px" class="muted">Upload / Share</div>
          <div class="card" style="margin-top:8px">
            <input id="fileInput" type="file" multiple />
            <div style="height:8px"></div>
            <input id="shareTo" placeholder="Share to server id (e.g. 98765)" />
            <button id="shareSelected" class="mini">Share Selected -> Target</button>
            <div style="height:8px"></div>
            <button id="deleteSelected" class="mini">Delete Selected</button>
          </div>

          <div style="margin-top:10px" class="muted">Files</div>
          <div id="fileArea" class="card" style="margin-top:8px;max-height:380px;overflow:auto"></div>
        </div>

        <div>
          <div class="muted">Chat Room</div>
          <div class="card" style="margin-top:8px">
            <div id="chatArea" class="chat"></div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <input id="chatName" placeholder="your name" style="width:140px" />
              <input id="chatMsg" placeholder="message..." style="flex:1" />
              <button id="sendChat" class="mini">Send</button>
            </div>
            <div style="margin-top:8px" class="muted">Chat messages are per-server and persisted locally.</div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <footer style="margin-top:14px;color:#9db0d6;font-size:13px">Deterministic base + IndexedDB-backed delta store. Extend with network sync for live multi-user chat.</footer>
</div>

<script>
// CONFIG
const TOTAL_SERVERS = 10_000_000_000;
const MAX_FILES_PER_SERVER = 128;
const FILES_PREVIEW = 200;

// ===== IndexedDB helpers =====
function openDb(){
  return new Promise((res, rej) => {
    const rq = indexedDB.open('virtual-1b-servers', 1);
    rq.onupgradeneeded = e => {
      const db = e.target.result;
      if(!db.objectStoreNames.contains('servers')) db.createObjectStore('servers');
    };
    rq.onsuccess = e => res(e.target.result);
    rq.onerror = e => rej(e.target.error);
  });
}
async function idbGet(key){ const db = await openDb(); return new Promise((res,rej)=>{ const tx=db.transaction('servers','readonly'); const store=tx.objectStore('servers'); const r=store.get(key); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbPut(key,val){ const db=await openDb(); return new Promise((res,rej)=>{ const tx=db.transaction('servers','readwrite'); const store=tx.objectStore('servers'); const r=store.put(val,key); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error); }); }
async function idbDelete(key){ const db=await openDb(); return new Promise((res,rej)=>{ const tx=db.transaction('servers','readwrite'); const store=tx.objectStore('servers'); const r=store.delete(key); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error); }); }

// ===== Deterministic generator (xorshift32) =====
function xorshift32(seed){ let x=seed>>>0; return function(){ x^=x<<13; x>>>=0; x^=x>>>17; x>>>=0; x^=x<<5; x>>>=0; return x>>>0; }; }
function generateBaseServer(serverId){ const rand=xorshift32(serverId+0x9e3779b1); const numFiles=rand()%(MAX_FILES_PER_SERVER+1); const files=new Array(numFiles); for(let i=0;i<numFiles;i++){ const r1=rand(); const name=`file_${(r1%1_000_000).toString().padStart(6,'0')}.dat`; const size=rand()%(1024*1024*10); const hash=((r1>>>5)^rand()).toString(16).slice(0,8); files[i]={ name, size, hash, createdAt:new Date(1600000000000 + (serverId%1_000_000)*1000 + i*1000).toISOString() }; } const meta={ id:serverId, owner:`owner_${serverId%10000}`, createdAt:new Date(1600000000000 + (serverId%1_000_000)*1000).toISOString() }; return { id:serverId, files, meta, chat:[] }; }

// In-memory cache for quick UX; persistence occurs in IndexedDB when mutated.
const inMemoryCache = new Map();
async function loadServer(serverId){ serverId=Number(serverId); if(inMemoryCache.has(serverId)) return inMemoryCache.get(serverId); const key=`server:${serverId}`; const stored=await idbGet(key); if(stored){ inMemoryCache.set(serverId, stored); updateCacheUI(); return stored; } const base=generateBaseServer(serverId); inMemoryCache.set(serverId, base); updateCacheUI(); return base; }
async function persistServer(server){ const key=`server:${server.id}`; await idbPut(key, server); inMemoryCache.set(server.id, server); updateCacheUI(); }
async function clearPersist(serverId){ const key=`server:${serverId}`; await idbDelete(key); const base=generateBaseServer(serverId); inMemoryCache.set(serverId, base); updateCacheUI(); }
function updateCacheUI(){ document.getElementById('cacheSize').textContent = inMemoryCache.size; }

// ===== UI bindings =====
const listView = document.getElementById('listView');
const detailView = document.getElementById('detailView');
const serverGrid = document.getElementById('serverGrid');
const pageStartInput = document.getElementById('pageStart');
const pageSizeInput = document.getElementById('pageSize');
const renderPageBtn = document.getElementById('renderPage');
const gotoInput = document.getElementById('gotoId');
const openIdBtn = document.getElementById('openIdBtn');
const backToListBtn = document.getElementById('backToList');
const detailIdEl = document.getElementById('detailId');
const prevServerBtn = document.getElementById('prevServer');
const nextServerBtn = document.getElementById('nextServer');
const clearDetailPersistBtn = document.getElementById('clearDetailPersist');
const fileInput = document.getElementById('fileInput');
const shareSelectedBtn = document.getElementById('shareSelected');
const shareToInput = document.getElementById('shareTo');
const deleteSelectedBtn = document.getElementById('deleteSelected');
const serverInfoEl = document.getElementById('serverInfo');
const fileAreaEl = document.getElementById('fileArea');
const chatArea = document.getElementById('chatArea');
const chatName = document.getElementById('chatName');
const chatMsg = document.getElementById('chatMsg');
const sendChatBtn = document.getElementById('sendChat');

document.getElementById('totalServers').textContent = TOTAL_SERVERS.toLocaleString();

let currentDetailId = null;

// Render a page of server cards (paged display only ‚Äî doesn't allocate servers until opened)
function renderServerPage(start, size){ serverGrid.innerHTML=''; start = Math.max(0, Number(start)||0); size = Math.min(500, Math.max(1, Number(size)||100)); for(let i=0;i<size;i++){ const id = start + i; if(id >= TOTAL_SERVERS) break; const card = document.createElement('div'); card.className='server-card'; card.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong>ID ${id}</strong><div class=\"muted\">owner: owner_${id%10000}</div></div><div><button class=\"mini openBtn\" data-id=\"${id}\">Open</button></div></div>`; serverGrid.appendChild(card); } // attach open listeners
  serverGrid.querySelectorAll('.openBtn').forEach(btn=> btn.onclick = ()=> openServer(btn.dataset.id) ); }

// Open a server into detail view
async function openServer(serverId){ currentDetailId = Number(serverId); detailIdEl.textContent = currentDetailId; listView.classList.add('hidden'); detailView.classList.remove('hidden'); await renderDetail(currentDetailId); }

async function closeDetail(){ currentDetailId = null; detailIdEl.textContent='-'; detailView.classList.add('hidden'); listView.classList.remove('hidden'); }

// Render server detail (info, files, chat)
async function renderDetail(serverId){ const srv = await loadServer(serverId);
  // info
  serverInfoEl.innerHTML = `\
    <div><strong>ID:</strong> ${srv.id}</div>\
    <div><strong>Owner:</strong> ${srv.meta.owner}</div>\
    <div><strong>Created:</strong> ${srv.meta.createdAt}</div>\
    <div class=\"muted\">Files: ${srv.files.length} ‚Ä¢ Chat messages: ${srv.chat.length}</div>\
  `;
  // files list
  fileAreaEl.innerHTML=''; const list=document.createElement('div'); list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='6px'; const files=srv.files; const limit=Math.min(files.length, FILES_PREVIEW);
  for(let i=0;i<limit;i++){ const f=files[i]; const row=document.createElement('div'); row.className='file-row'; row.innerHTML = `<div style=\"flex:1\">${escapeHtml(f.name)} <span class=\"muted\">(${f.size} bytes)</span></div>`; const chk=document.createElement('input'); chk.type='checkbox'; chk.dataset.index=i; const btnDownload=document.createElement('button'); btnDownload.textContent='Download'; btnDownload.className='mini'; btnDownload.onclick=()=> simulateDownload(f); const btnDelete=document.createElement('button'); btnDelete.textContent='Delete'; btnDelete.className='mini'; btnDelete.onclick = async ()=>{ if(!confirm('Delete file '+f.name+'?')) return; srv.files.splice(i,1); await persistServer(srv); await renderDetail(serverId); }; row.appendChild(chk); row.appendChild(btnDownload); row.appendChild(btnDelete); list.appendChild(row); }
  if(files.length>limit){ const more=document.createElement('div'); more.className='muted'; more.textContent = `... and ${files.length-limit} more files (preview)`; list.appendChild(more); }
  fileAreaEl.appendChild(list);
  // chat
  renderChat(srv);
}

function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]); }

function simulateDownload(file){ const content = `Simulated file: ${file.name}
size:${file.size}
hash:${file.hash || 'na'}`; const blob=new Blob([content],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=file.name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }

// Upload handling for detail view
fileInput.onchange = async (e)=>{ if(currentDetailId===null) return alert('Open a server first'); const id = Number(currentDetailId); const srv = await loadServer(id); const files = Array.from(e.target.files); for(const f of files){ const entry = { name:f.name, size:f.size, createdAt:new Date().toISOString(), hash:(Math.random()*0xFFFFFF<<0).toString(16) }; srv.files.unshift(entry); } await persistServer(srv); await renderDetail(id); fileInput.value=''; }

// Share selected files to another server (copy)
shareSelectedBtn.onclick = async ()=>{ if(currentDetailId===null) return alert('Open a server first'); const fromId = Number(currentDetailId); const toId = Number(shareToInput.value); if(Number.isNaN(toId) || toId<0 || toId>=TOTAL_SERVERS) return alert('Invalid target server id'); const fromSrv = await loadServer(fromId); const checks = Array.from(fileAreaEl.querySelectorAll('input[type=checkbox]')).filter(c=>c.checked); if(checks.length===0) return alert('No files selected'); const toSrv = await loadServer(toId); for(const c of checks){ const idx = Number(c.dataset.index); const f = Object.assign({}, fromSrv.files[idx]); f.createdAt = new Date().toISOString(); toSrv.files.unshift(f); } await persistServer(toSrv); alert(`Shared ${checks.length} file(s) to server ${toId}`); }

// Delete selected files
deleteSelectedBtn.onclick = async ()=>{ if(currentDetailId===null) return alert('Open a server first'); const id=Number(currentDetailId); const srv = await loadServer(id); const checks = Array.from(fileAreaEl.querySelectorAll('input[type=checkbox]')).filter(c=>c.checked); if(checks.length===0) return alert('No files selected'); // delete highest indices first to keep indices stable
  const indices = checks.map(c=>Number(c.dataset.index)).sort((a,b)=>b-a);
  for(const idx of indices) srv.files.splice(idx,1);
  await persistServer(srv);
  await renderDetail(id);
}

// Clear persistence for current detail
clearDetailPersistBtn.onclick = async ()=>{ if(currentDetailId===null) return; if(!confirm('Clear persisted changes for server '+currentDetailId+'?')) return; await clearPersist(currentDetailId); await renderDetail(currentDetailId); }

// Chat send
sendChatBtn.onclick = async ()=>{ if(currentDetailId===null) return alert('Open a server first'); const id = Number(currentDetailId); const name = (chatName.value || 'anon').trim(); const text = (chatMsg.value || '').trim(); if(!text) return; chatMsg.value=''; const srv = await loadServer(id); const msg = { name, text, ts: new Date().toLocaleString() }; srv.chat.push(msg); if(srv.chat.length>2000) srv.chat.splice(0, srv.chat.length-2000); await persistServer(srv); renderChat(srv); }
function renderChat(server){ chatArea.innerHTML=''; for(const m of server.chat.slice(-500)){ const el=document.createElement('div'); el.className='chat-msg'; el.innerHTML = `<strong>${escapeHtml(m.name)}</strong> <span class="muted mini">${m.ts}</span><div>${escapeHtml(m.text)}</div>`; chatArea.appendChild(el); } chatArea.scrollTop = chatArea.scrollHeight; }

// Navigation & list handlers
renderPageBtn.onclick = ()=> { renderServerPage(Number(pageStartInput.value||0), Number(pageSizeInput.value||100)); };
openIdBtn.onclick = ()=> { const id = Number(gotoInput.value); if(Number.isNaN(id)||id<0||id>=TOTAL_SERVERS) return alert('Invalid server id'); openServer(id); };
backToListBtn.onclick = ()=> closeDetail();
prevServerBtn.onclick = ()=> { if(currentDetailId===null) return; openServer(Math.max(0, currentDetailId-1)); };
nextServerBtn.onclick = ()=> { if(currentDetailId===null) return; openServer(Math.min(TOTAL_SERVERS-1, currentDetailId+1)); };

// initial render
renderServerPage(Number(pageStartInput.value||0), Number(pageSizeInput.value||100)); document.getElementById('gotoId').value=''; updateCacheUI();

</script>
</body>
</html>
